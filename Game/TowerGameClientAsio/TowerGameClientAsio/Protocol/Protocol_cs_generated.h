// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_
#define FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_

#include "flatbuffers/flatbuffers.h"

namespace ProtocolCS {

struct playerInfo;

namespace Login {

struct LoginReq;

struct LoginAck;

}  // namespace Login

namespace Game {

struct GameMatchingReq;

struct GameMatchingCancelReq;

struct GameMatchingCancelNotify;

struct GameMatchingNotify;

struct GameReadyReq;

struct GameReadyAck;

struct GameReadyNotify;

struct GameLoadingFinishReq;

struct GameLoadingFinishAck;

struct GameStartNotify;

struct GameStatusNotify;

struct GameGiveUpReq;

struct GameGiveUpNotify;

struct GameEndReq;

struct GameEndAck;

struct GameEndNotify;

}  // namespace Game

namespace P2P {

struct BuildReq;

struct SellTowerReq;

struct UpgradeTowerReq;

struct KillUnitReq;

struct PlayerLoseReq;

}  // namespace P2P

struct ErrorMsg;

struct MessageRoot;

enum E_GameStatus {
  E_GameStatus_NONE = 0,
  E_GameStatus_LOADING = 1,
  E_GameStatus_START = 2,
  E_GameStatus_PLAYING = 3,
  E_GameStatus_RESULT = 4,
  E_GameStatus_END = 5,
  E_GameStatus_MIN = E_GameStatus_NONE,
  E_GameStatus_MAX = E_GameStatus_END
};

inline const char **EnumNamesE_GameStatus() {
  static const char *names[] = { "NONE", "LOADING", "START", "PLAYING", "RESULT", "END", nullptr };
  return names;
}

inline const char *EnumNameE_GameStatus(E_GameStatus e) { return EnumNamesE_GameStatus()[static_cast<int>(e)]; }

enum E_ErrorResult {
  E_ErrorResult_INVAILD_USERID = 0,
  E_ErrorResult_INVAILD_ROOM = 1,
  E_ErrorResult_EXPIRE_ROOM = 2,
  E_ErrorResult_NOT_JOIN_ROOM = 3,
  E_ErrorResult_INVAILD_GAME_STATE = 4,
  E_ErrorResult_MIN = E_ErrorResult_INVAILD_USERID,
  E_ErrorResult_MAX = E_ErrorResult_INVAILD_GAME_STATE
};

inline const char **EnumNamesE_ErrorResult() {
  static const char *names[] = { "INVAILD_USERID", "INVAILD_ROOM", "EXPIRE_ROOM", "NOT_JOIN_ROOM", "INVAILD_GAME_STATE", nullptr };
  return names;
}

inline const char *EnumNameE_ErrorResult(E_ErrorResult e) { return EnumNamesE_ErrorResult()[static_cast<int>(e)]; }

enum MessageType {
  MessageType_NONE = 0,
  MessageType_ErrorMsg = 1,
  MessageType_Login_LoginReq = 2,
  MessageType_Login_LoginAck = 3,
  MessageType_Game_GameMatchingReq = 4,
  MessageType_Game_GameMatchingNotify = 5,
  MessageType_Game_GameMatchingCancelReq = 6,
  MessageType_Game_GameMatchingCancelNotify = 7,
  MessageType_Game_GameReadyReq = 8,
  MessageType_Game_GameReadyAck = 9,
  MessageType_Game_GameReadyNotify = 10,
  MessageType_Game_GameLoadingFinishReq = 11,
  MessageType_Game_GameLoadingFinishAck = 12,
  MessageType_Game_GameStartNotify = 13,
  MessageType_Game_GameStatusNotify = 14,
  MessageType_Game_GameGiveUpReq = 15,
  MessageType_Game_GameGiveUpNotify = 16,
  MessageType_Game_GameEndReq = 17,
  MessageType_Game_GameEndAck = 18,
  MessageType_Game_GameEndNotify = 19,
  MessageType_P2P_BuildReq = 20,
  MessageType_P2P_SellTowerReq = 21,
  MessageType_P2P_UpgradeTowerReq = 22,
  MessageType_P2P_KillUnitReq = 23,
  MessageType_P2P_PlayerLoseReq = 24,
  MessageType_MIN = MessageType_NONE,
  MessageType_MAX = MessageType_P2P_PlayerLoseReq
};

inline const char **EnumNamesMessageType() {
  static const char *names[] = { "NONE", "ErrorMsg", "Login_LoginReq", "Login_LoginAck", "Game_GameMatchingReq", "Game_GameMatchingNotify", "Game_GameMatchingCancelReq", "Game_GameMatchingCancelNotify", "Game_GameReadyReq", "Game_GameReadyAck", "Game_GameReadyNotify", "Game_GameLoadingFinishReq", "Game_GameLoadingFinishAck", "Game_GameStartNotify", "Game_GameStatusNotify", "Game_GameGiveUpReq", "Game_GameGiveUpNotify", "Game_GameEndReq", "Game_GameEndAck", "Game_GameEndNotify", "P2P_BuildReq", "P2P_SellTowerReq", "P2P_UpgradeTowerReq", "P2P_KillUnitReq", "P2P_PlayerLoseReq", nullptr };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) { return EnumNamesMessageType()[static_cast<int>(e)]; }

template<typename T> struct MessageTypeTraits {
  static const MessageType enum_value = MessageType_NONE;
};

template<> struct MessageTypeTraits<ErrorMsg> {
  static const MessageType enum_value = MessageType_ErrorMsg;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::LoginReq> {
  static const MessageType enum_value = MessageType_Login_LoginReq;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::LoginAck> {
  static const MessageType enum_value = MessageType_Login_LoginAck;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameMatchingReq> {
  static const MessageType enum_value = MessageType_Game_GameMatchingReq;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameMatchingNotify> {
  static const MessageType enum_value = MessageType_Game_GameMatchingNotify;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameMatchingCancelReq> {
  static const MessageType enum_value = MessageType_Game_GameMatchingCancelReq;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameMatchingCancelNotify> {
  static const MessageType enum_value = MessageType_Game_GameMatchingCancelNotify;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameReadyReq> {
  static const MessageType enum_value = MessageType_Game_GameReadyReq;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameReadyAck> {
  static const MessageType enum_value = MessageType_Game_GameReadyAck;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameReadyNotify> {
  static const MessageType enum_value = MessageType_Game_GameReadyNotify;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameLoadingFinishReq> {
  static const MessageType enum_value = MessageType_Game_GameLoadingFinishReq;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameLoadingFinishAck> {
  static const MessageType enum_value = MessageType_Game_GameLoadingFinishAck;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameStartNotify> {
  static const MessageType enum_value = MessageType_Game_GameStartNotify;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameStatusNotify> {
  static const MessageType enum_value = MessageType_Game_GameStatusNotify;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameGiveUpReq> {
  static const MessageType enum_value = MessageType_Game_GameGiveUpReq;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameGiveUpNotify> {
  static const MessageType enum_value = MessageType_Game_GameGiveUpNotify;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameEndReq> {
  static const MessageType enum_value = MessageType_Game_GameEndReq;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameEndAck> {
  static const MessageType enum_value = MessageType_Game_GameEndAck;
};

template<> struct MessageTypeTraits<ProtocolCS::Game::GameEndNotify> {
  static const MessageType enum_value = MessageType_Game_GameEndNotify;
};

template<> struct MessageTypeTraits<ProtocolCS::P2P::BuildReq> {
  static const MessageType enum_value = MessageType_P2P_BuildReq;
};

template<> struct MessageTypeTraits<ProtocolCS::P2P::SellTowerReq> {
  static const MessageType enum_value = MessageType_P2P_SellTowerReq;
};

template<> struct MessageTypeTraits<ProtocolCS::P2P::UpgradeTowerReq> {
  static const MessageType enum_value = MessageType_P2P_UpgradeTowerReq;
};

template<> struct MessageTypeTraits<ProtocolCS::P2P::KillUnitReq> {
  static const MessageType enum_value = MessageType_P2P_KillUnitReq;
};

template<> struct MessageTypeTraits<ProtocolCS::P2P::PlayerLoseReq> {
  static const MessageType enum_value = MessageType_P2P_PlayerLoseReq;
};

inline bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *union_obj, MessageType type);

struct playerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTUID = 4,
    VT_PLAYERIDX = 6,
    VT_USERID = 8,
    VT_POINT = 10
  };
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  int32_t playerIdx() const { return GetField<int32_t>(VT_PLAYERIDX, 0); }
  const flatbuffers::String *userID() const { return GetPointer<const flatbuffers::String *>(VT_USERID); }
  int32_t point() const { return GetField<int32_t>(VT_POINT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           VerifyField<int32_t>(verifier, VT_PLAYERIDX) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USERID) &&
           verifier.Verify(userID()) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
};

struct playerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(playerInfo::VT_ACCOUNTUID, accountUID, 0); }
  void add_playerIdx(int32_t playerIdx) { fbb_.AddElement<int32_t>(playerInfo::VT_PLAYERIDX, playerIdx, 0); }
  void add_userID(flatbuffers::Offset<flatbuffers::String> userID) { fbb_.AddOffset(playerInfo::VT_USERID, userID); }
  void add_point(int32_t point) { fbb_.AddElement<int32_t>(playerInfo::VT_POINT, point, 0); }
  playerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  playerInfoBuilder &operator=(const playerInfoBuilder &);
  flatbuffers::Offset<playerInfo> Finish() {
    auto o = flatbuffers::Offset<playerInfo>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<playerInfo> CreateplayerInfo(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountUID = 0,
    int32_t playerIdx = 0,
    flatbuffers::Offset<flatbuffers::String> userID = 0,
    int32_t point = 0) {
  playerInfoBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_point(point);
  builder_.add_userID(userID);
  builder_.add_playerIdx(playerIdx);
  return builder_.Finish();
}

inline flatbuffers::Offset<playerInfo> CreateplayerInfoDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountUID = 0,
    int32_t playerIdx = 0,
    const char *userID = nullptr,
    int32_t point = 0) {
  return CreateplayerInfo(_fbb, accountUID, playerIdx, userID ? _fbb.CreateString(userID) : 0, point);
}

namespace Login {

struct LoginReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEVICETYPE = 4,
    VT_USERID = 6
  };
  int32_t deviceType() const { return GetField<int32_t>(VT_DEVICETYPE, 0); }
  const flatbuffers::String *userID() const { return GetPointer<const flatbuffers::String *>(VT_USERID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEVICETYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USERID) &&
           verifier.Verify(userID()) &&
           verifier.EndTable();
  }
};

struct LoginReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deviceType(int32_t deviceType) { fbb_.AddElement<int32_t>(LoginReq::VT_DEVICETYPE, deviceType, 0); }
  void add_userID(flatbuffers::Offset<flatbuffers::String> userID) { fbb_.AddOffset(LoginReq::VT_USERID, userID); }
  LoginReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LoginReqBuilder &operator=(const LoginReqBuilder &);
  flatbuffers::Offset<LoginReq> Finish() {
    auto o = flatbuffers::Offset<LoginReq>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<LoginReq> CreateLoginReq(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t deviceType = 0,
    flatbuffers::Offset<flatbuffers::String> userID = 0) {
  LoginReqBuilder builder_(_fbb);
  builder_.add_userID(userID);
  builder_.add_deviceType(deviceType);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginReq> CreateLoginReqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t deviceType = 0,
    const char *userID = nullptr) {
  return CreateLoginReq(_fbb, deviceType, userID ? _fbb.CreateString(userID) : 0);
}

struct LoginAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_GAMESERVERID = 6,
    VT_ACCOUNTUID = 8
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  int32_t gameServerID() const { return GetField<int32_t>(VT_GAMESERVERID, 0); }
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_GAMESERVERID) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           verifier.EndTable();
  }
};

struct LoginAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(LoginAck::VT_RESULT, result, 0); }
  void add_gameServerID(int32_t gameServerID) { fbb_.AddElement<int32_t>(LoginAck::VT_GAMESERVERID, gameServerID, 0); }
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(LoginAck::VT_ACCOUNTUID, accountUID, 0); }
  LoginAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LoginAckBuilder &operator=(const LoginAckBuilder &);
  flatbuffers::Offset<LoginAck> Finish() {
    auto o = flatbuffers::Offset<LoginAck>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<LoginAck> CreateLoginAck(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t gameServerID = 0,
    int64_t accountUID = 0) {
  LoginAckBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_gameServerID(gameServerID);
  builder_.add_result(result);
  return builder_.Finish();
}

}  // namespace Login

namespace Game {

struct GameMatchingReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GAMESERVERID = 4
  };
  int32_t gameServerID() const { return GetField<int32_t>(VT_GAMESERVERID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GAMESERVERID) &&
           verifier.EndTable();
  }
};

struct GameMatchingReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gameServerID(int32_t gameServerID) { fbb_.AddElement<int32_t>(GameMatchingReq::VT_GAMESERVERID, gameServerID, 0); }
  GameMatchingReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameMatchingReqBuilder &operator=(const GameMatchingReqBuilder &);
  flatbuffers::Offset<GameMatchingReq> Finish() {
    auto o = flatbuffers::Offset<GameMatchingReq>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameMatchingReq> CreateGameMatchingReq(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t gameServerID = 0) {
  GameMatchingReqBuilder builder_(_fbb);
  builder_.add_gameServerID(gameServerID);
  return builder_.Finish();
}

struct GameMatchingCancelReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GAMESERVERID = 4
  };
  int32_t gameServerID() const { return GetField<int32_t>(VT_GAMESERVERID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GAMESERVERID) &&
           verifier.EndTable();
  }
};

struct GameMatchingCancelReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gameServerID(int32_t gameServerID) { fbb_.AddElement<int32_t>(GameMatchingCancelReq::VT_GAMESERVERID, gameServerID, 0); }
  GameMatchingCancelReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameMatchingCancelReqBuilder &operator=(const GameMatchingCancelReqBuilder &);
  flatbuffers::Offset<GameMatchingCancelReq> Finish() {
    auto o = flatbuffers::Offset<GameMatchingCancelReq>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameMatchingCancelReq> CreateGameMatchingCancelReq(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t gameServerID = 0) {
  GameMatchingCancelReqBuilder builder_(_fbb);
  builder_.add_gameServerID(gameServerID);
  return builder_.Finish();
}

struct GameMatchingCancelNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct GameMatchingCancelNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(GameMatchingCancelNotify::VT_RESULT, result, 0); }
  GameMatchingCancelNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameMatchingCancelNotifyBuilder &operator=(const GameMatchingCancelNotifyBuilder &);
  flatbuffers::Offset<GameMatchingCancelNotify> Finish() {
    auto o = flatbuffers::Offset<GameMatchingCancelNotify>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameMatchingCancelNotify> CreateGameMatchingCancelNotify(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0) {
  GameMatchingCancelNotifyBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GameMatchingNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_ROOMUID = 6,
    VT_CURRENTSERVERTIME = 8,
    VT_READYTIME = 10
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  int32_t roomUID() const { return GetField<int32_t>(VT_ROOMUID, 0); }
  int64_t currentServerTime() const { return GetField<int64_t>(VT_CURRENTSERVERTIME, 0); }
  int64_t readyTime() const { return GetField<int64_t>(VT_READYTIME, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_ROOMUID) &&
           VerifyField<int64_t>(verifier, VT_CURRENTSERVERTIME) &&
           VerifyField<int64_t>(verifier, VT_READYTIME) &&
           verifier.EndTable();
  }
};

struct GameMatchingNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(GameMatchingNotify::VT_RESULT, result, 0); }
  void add_roomUID(int32_t roomUID) { fbb_.AddElement<int32_t>(GameMatchingNotify::VT_ROOMUID, roomUID, 0); }
  void add_currentServerTime(int64_t currentServerTime) { fbb_.AddElement<int64_t>(GameMatchingNotify::VT_CURRENTSERVERTIME, currentServerTime, 0); }
  void add_readyTime(int64_t readyTime) { fbb_.AddElement<int64_t>(GameMatchingNotify::VT_READYTIME, readyTime, 0); }
  GameMatchingNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameMatchingNotifyBuilder &operator=(const GameMatchingNotifyBuilder &);
  flatbuffers::Offset<GameMatchingNotify> Finish() {
    auto o = flatbuffers::Offset<GameMatchingNotify>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<GameMatchingNotify> CreateGameMatchingNotify(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t roomUID = 0,
    int64_t currentServerTime = 0,
    int64_t readyTime = 0) {
  GameMatchingNotifyBuilder builder_(_fbb);
  builder_.add_readyTime(readyTime);
  builder_.add_currentServerTime(currentServerTime);
  builder_.add_roomUID(roomUID);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GameReadyReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROOMUID = 4,
    VT_DECKIDX = 6
  };
  int32_t roomUID() const { return GetField<int32_t>(VT_ROOMUID, 0); }
  int32_t deckIdx() const { return GetField<int32_t>(VT_DECKIDX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROOMUID) &&
           VerifyField<int32_t>(verifier, VT_DECKIDX) &&
           verifier.EndTable();
  }
};

struct GameReadyReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_roomUID(int32_t roomUID) { fbb_.AddElement<int32_t>(GameReadyReq::VT_ROOMUID, roomUID, 0); }
  void add_deckIdx(int32_t deckIdx) { fbb_.AddElement<int32_t>(GameReadyReq::VT_DECKIDX, deckIdx, 0); }
  GameReadyReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameReadyReqBuilder &operator=(const GameReadyReqBuilder &);
  flatbuffers::Offset<GameReadyReq> Finish() {
    auto o = flatbuffers::Offset<GameReadyReq>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<GameReadyReq> CreateGameReadyReq(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t roomUID = 0,
    int32_t deckIdx = 0) {
  GameReadyReqBuilder builder_(_fbb);
  builder_.add_deckIdx(deckIdx);
  builder_.add_roomUID(roomUID);
  return builder_.Finish();
}

struct GameReadyAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct GameReadyAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(GameReadyAck::VT_RESULT, result, 0); }
  GameReadyAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameReadyAckBuilder &operator=(const GameReadyAckBuilder &);
  flatbuffers::Offset<GameReadyAck> Finish() {
    auto o = flatbuffers::Offset<GameReadyAck>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameReadyAck> CreateGameReadyAck(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0) {
  GameReadyAckBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GameReadyNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GROUPHOSTID = 4,
    VT_PLAYERINFOS = 6
  };
  int32_t groupHostID() const { return GetField<int32_t>(VT_GROUPHOSTID, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>> *playerInfos() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>> *>(VT_PLAYERINFOS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GROUPHOSTID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLAYERINFOS) &&
           verifier.Verify(playerInfos()) &&
           verifier.VerifyVectorOfTables(playerInfos()) &&
           verifier.EndTable();
  }
};

struct GameReadyNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_groupHostID(int32_t groupHostID) { fbb_.AddElement<int32_t>(GameReadyNotify::VT_GROUPHOSTID, groupHostID, 0); }
  void add_playerInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>>> playerInfos) { fbb_.AddOffset(GameReadyNotify::VT_PLAYERINFOS, playerInfos); }
  GameReadyNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameReadyNotifyBuilder &operator=(const GameReadyNotifyBuilder &);
  flatbuffers::Offset<GameReadyNotify> Finish() {
    auto o = flatbuffers::Offset<GameReadyNotify>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<GameReadyNotify> CreateGameReadyNotify(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t groupHostID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>>> playerInfos = 0) {
  GameReadyNotifyBuilder builder_(_fbb);
  builder_.add_playerInfos(playerInfos);
  builder_.add_groupHostID(groupHostID);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameReadyNotify> CreateGameReadyNotifyDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t groupHostID = 0,
    const std::vector<flatbuffers::Offset<ProtocolCS::playerInfo>> *playerInfos = nullptr) {
  return CreateGameReadyNotify(_fbb, groupHostID, playerInfos ? _fbb.CreateVector<flatbuffers::Offset<ProtocolCS::playerInfo>>(*playerInfos) : 0);
}

struct GameLoadingFinishReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROOMUID = 4
  };
  int32_t roomUID() const { return GetField<int32_t>(VT_ROOMUID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROOMUID) &&
           verifier.EndTable();
  }
};

struct GameLoadingFinishReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_roomUID(int32_t roomUID) { fbb_.AddElement<int32_t>(GameLoadingFinishReq::VT_ROOMUID, roomUID, 0); }
  GameLoadingFinishReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameLoadingFinishReqBuilder &operator=(const GameLoadingFinishReqBuilder &);
  flatbuffers::Offset<GameLoadingFinishReq> Finish() {
    auto o = flatbuffers::Offset<GameLoadingFinishReq>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameLoadingFinishReq> CreateGameLoadingFinishReq(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t roomUID = 0) {
  GameLoadingFinishReqBuilder builder_(_fbb);
  builder_.add_roomUID(roomUID);
  return builder_.Finish();
}

struct GameLoadingFinishAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct GameLoadingFinishAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(GameLoadingFinishAck::VT_RESULT, result, 0); }
  GameLoadingFinishAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameLoadingFinishAckBuilder &operator=(const GameLoadingFinishAckBuilder &);
  flatbuffers::Offset<GameLoadingFinishAck> Finish() {
    auto o = flatbuffers::Offset<GameLoadingFinishAck>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameLoadingFinishAck> CreateGameLoadingFinishAck(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0) {
  GameLoadingFinishAckBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GameStartNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENTSERVERTIME = 4
  };
  int64_t currentServerTime() const { return GetField<int64_t>(VT_CURRENTSERVERTIME, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CURRENTSERVERTIME) &&
           verifier.EndTable();
  }
};

struct GameStartNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currentServerTime(int64_t currentServerTime) { fbb_.AddElement<int64_t>(GameStartNotify::VT_CURRENTSERVERTIME, currentServerTime, 0); }
  GameStartNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameStartNotifyBuilder &operator=(const GameStartNotifyBuilder &);
  flatbuffers::Offset<GameStartNotify> Finish() {
    auto o = flatbuffers::Offset<GameStartNotify>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameStartNotify> CreateGameStartNotify(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t currentServerTime = 0) {
  GameStartNotifyBuilder builder_(_fbb);
  builder_.add_currentServerTime(currentServerTime);
  return builder_.Finish();
}

struct GameStatusNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GAMESTAUTS = 4,
    VT_CURRENTSERVERTIME = 6,
    VT_PLAYTIME = 8
  };
  ProtocolCS::E_GameStatus gameStauts() const { return static_cast<ProtocolCS::E_GameStatus>(GetField<int32_t>(VT_GAMESTAUTS, 0)); }
  int64_t currentServerTime() const { return GetField<int64_t>(VT_CURRENTSERVERTIME, 0); }
  float playTime() const { return GetField<float>(VT_PLAYTIME, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GAMESTAUTS) &&
           VerifyField<int64_t>(verifier, VT_CURRENTSERVERTIME) &&
           VerifyField<float>(verifier, VT_PLAYTIME) &&
           verifier.EndTable();
  }
};

struct GameStatusNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gameStauts(ProtocolCS::E_GameStatus gameStauts) { fbb_.AddElement<int32_t>(GameStatusNotify::VT_GAMESTAUTS, static_cast<int32_t>(gameStauts), 0); }
  void add_currentServerTime(int64_t currentServerTime) { fbb_.AddElement<int64_t>(GameStatusNotify::VT_CURRENTSERVERTIME, currentServerTime, 0); }
  void add_playTime(float playTime) { fbb_.AddElement<float>(GameStatusNotify::VT_PLAYTIME, playTime, 0.0f); }
  GameStatusNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameStatusNotifyBuilder &operator=(const GameStatusNotifyBuilder &);
  flatbuffers::Offset<GameStatusNotify> Finish() {
    auto o = flatbuffers::Offset<GameStatusNotify>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<GameStatusNotify> CreateGameStatusNotify(flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::E_GameStatus gameStauts = ProtocolCS::E_GameStatus_NONE,
    int64_t currentServerTime = 0,
    float playTime = 0.0f) {
  GameStatusNotifyBuilder builder_(_fbb);
  builder_.add_currentServerTime(currentServerTime);
  builder_.add_playTime(playTime);
  builder_.add_gameStauts(gameStauts);
  return builder_.Finish();
}

struct GameGiveUpReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROOMUID = 4
  };
  int32_t roomUID() const { return GetField<int32_t>(VT_ROOMUID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROOMUID) &&
           verifier.EndTable();
  }
};

struct GameGiveUpReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_roomUID(int32_t roomUID) { fbb_.AddElement<int32_t>(GameGiveUpReq::VT_ROOMUID, roomUID, 0); }
  GameGiveUpReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameGiveUpReqBuilder &operator=(const GameGiveUpReqBuilder &);
  flatbuffers::Offset<GameGiveUpReq> Finish() {
    auto o = flatbuffers::Offset<GameGiveUpReq>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameGiveUpReq> CreateGameGiveUpReq(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t roomUID = 0) {
  GameGiveUpReqBuilder builder_(_fbb);
  builder_.add_roomUID(roomUID);
  return builder_.Finish();
}

struct GameGiveUpNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_ACCOUNTUID = 6
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           verifier.EndTable();
  }
};

struct GameGiveUpNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(GameGiveUpNotify::VT_RESULT, result, 0); }
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(GameGiveUpNotify::VT_ACCOUNTUID, accountUID, 0); }
  GameGiveUpNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameGiveUpNotifyBuilder &operator=(const GameGiveUpNotifyBuilder &);
  flatbuffers::Offset<GameGiveUpNotify> Finish() {
    auto o = flatbuffers::Offset<GameGiveUpNotify>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<GameGiveUpNotify> CreateGameGiveUpNotify(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t accountUID = 0) {
  GameGiveUpNotifyBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GameEndReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GAMERESULT = 4
  };
  int32_t gameResult() const { return GetField<int32_t>(VT_GAMERESULT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GAMERESULT) &&
           verifier.EndTable();
  }
};

struct GameEndReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gameResult(int32_t gameResult) { fbb_.AddElement<int32_t>(GameEndReq::VT_GAMERESULT, gameResult, 0); }
  GameEndReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameEndReqBuilder &operator=(const GameEndReqBuilder &);
  flatbuffers::Offset<GameEndReq> Finish() {
    auto o = flatbuffers::Offset<GameEndReq>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameEndReq> CreateGameEndReq(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t gameResult = 0) {
  GameEndReqBuilder builder_(_fbb);
  builder_.add_gameResult(gameResult);
  return builder_.Finish();
}

struct GameEndAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_BEFOREPOINT = 6,
    VT_AFTERPOINT = 8,
    VT_CURRENTSERVERTIME = 10
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  int32_t beforePoint() const { return GetField<int32_t>(VT_BEFOREPOINT, 0); }
  int32_t afterPoint() const { return GetField<int32_t>(VT_AFTERPOINT, 0); }
  int64_t currentServerTime() const { return GetField<int64_t>(VT_CURRENTSERVERTIME, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int32_t>(verifier, VT_BEFOREPOINT) &&
           VerifyField<int32_t>(verifier, VT_AFTERPOINT) &&
           VerifyField<int64_t>(verifier, VT_CURRENTSERVERTIME) &&
           verifier.EndTable();
  }
};

struct GameEndAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(GameEndAck::VT_RESULT, result, 0); }
  void add_beforePoint(int32_t beforePoint) { fbb_.AddElement<int32_t>(GameEndAck::VT_BEFOREPOINT, beforePoint, 0); }
  void add_afterPoint(int32_t afterPoint) { fbb_.AddElement<int32_t>(GameEndAck::VT_AFTERPOINT, afterPoint, 0); }
  void add_currentServerTime(int64_t currentServerTime) { fbb_.AddElement<int64_t>(GameEndAck::VT_CURRENTSERVERTIME, currentServerTime, 0); }
  GameEndAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameEndAckBuilder &operator=(const GameEndAckBuilder &);
  flatbuffers::Offset<GameEndAck> Finish() {
    auto o = flatbuffers::Offset<GameEndAck>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<GameEndAck> CreateGameEndAck(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t beforePoint = 0,
    int32_t afterPoint = 0,
    int64_t currentServerTime = 0) {
  GameEndAckBuilder builder_(_fbb);
  builder_.add_currentServerTime(currentServerTime);
  builder_.add_afterPoint(afterPoint);
  builder_.add_beforePoint(beforePoint);
  builder_.add_result(result);
  return builder_.Finish();
}

struct GameEndNotify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4,
    VT_WINNERACCOUNTUID = 6,
    VT_PLAYERINFOS = 8
  };
  int32_t result() const { return GetField<int32_t>(VT_RESULT, 0); }
  int64_t winnerAccountUID() const { return GetField<int64_t>(VT_WINNERACCOUNTUID, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>> *playerInfos() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>> *>(VT_PLAYERINFOS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           VerifyField<int64_t>(verifier, VT_WINNERACCOUNTUID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLAYERINFOS) &&
           verifier.Verify(playerInfos()) &&
           verifier.VerifyVectorOfTables(playerInfos()) &&
           verifier.EndTable();
  }
};

struct GameEndNotifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) { fbb_.AddElement<int32_t>(GameEndNotify::VT_RESULT, result, 0); }
  void add_winnerAccountUID(int64_t winnerAccountUID) { fbb_.AddElement<int64_t>(GameEndNotify::VT_WINNERACCOUNTUID, winnerAccountUID, 0); }
  void add_playerInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>>> playerInfos) { fbb_.AddOffset(GameEndNotify::VT_PLAYERINFOS, playerInfos); }
  GameEndNotifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameEndNotifyBuilder &operator=(const GameEndNotifyBuilder &);
  flatbuffers::Offset<GameEndNotify> Finish() {
    auto o = flatbuffers::Offset<GameEndNotify>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<GameEndNotify> CreateGameEndNotify(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t winnerAccountUID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProtocolCS::playerInfo>>> playerInfos = 0) {
  GameEndNotifyBuilder builder_(_fbb);
  builder_.add_winnerAccountUID(winnerAccountUID);
  builder_.add_playerInfos(playerInfos);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameEndNotify> CreateGameEndNotifyDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int64_t winnerAccountUID = 0,
    const std::vector<flatbuffers::Offset<ProtocolCS::playerInfo>> *playerInfos = nullptr) {
  return CreateGameEndNotify(_fbb, result, winnerAccountUID, playerInfos ? _fbb.CreateVector<flatbuffers::Offset<ProtocolCS::playerInfo>>(*playerInfos) : 0);
}

}  // namespace Game

namespace P2P {

struct BuildReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTUID = 4,
    VT_POSX = 6,
    VT_POSY = 8,
    VT_OBJECTID = 10
  };
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  int32_t posX() const { return GetField<int32_t>(VT_POSX, 0); }
  int32_t posY() const { return GetField<int32_t>(VT_POSY, 0); }
  int32_t objectID() const { return GetField<int32_t>(VT_OBJECTID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           VerifyField<int32_t>(verifier, VT_POSX) &&
           VerifyField<int32_t>(verifier, VT_POSY) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct BuildReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(BuildReq::VT_ACCOUNTUID, accountUID, 0); }
  void add_posX(int32_t posX) { fbb_.AddElement<int32_t>(BuildReq::VT_POSX, posX, 0); }
  void add_posY(int32_t posY) { fbb_.AddElement<int32_t>(BuildReq::VT_POSY, posY, 0); }
  void add_objectID(int32_t objectID) { fbb_.AddElement<int32_t>(BuildReq::VT_OBJECTID, objectID, 0); }
  BuildReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BuildReqBuilder &operator=(const BuildReqBuilder &);
  flatbuffers::Offset<BuildReq> Finish() {
    auto o = flatbuffers::Offset<BuildReq>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<BuildReq> CreateBuildReq(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountUID = 0,
    int32_t posX = 0,
    int32_t posY = 0,
    int32_t objectID = 0) {
  BuildReqBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_objectID(objectID);
  builder_.add_posY(posY);
  builder_.add_posX(posX);
  return builder_.Finish();
}

struct SellTowerReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTUID = 4,
    VT_POSX = 6,
    VT_POSY = 8,
    VT_OBJECTID = 10
  };
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  int32_t posX() const { return GetField<int32_t>(VT_POSX, 0); }
  int32_t posY() const { return GetField<int32_t>(VT_POSY, 0); }
  int32_t objectID() const { return GetField<int32_t>(VT_OBJECTID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           VerifyField<int32_t>(verifier, VT_POSX) &&
           VerifyField<int32_t>(verifier, VT_POSY) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct SellTowerReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(SellTowerReq::VT_ACCOUNTUID, accountUID, 0); }
  void add_posX(int32_t posX) { fbb_.AddElement<int32_t>(SellTowerReq::VT_POSX, posX, 0); }
  void add_posY(int32_t posY) { fbb_.AddElement<int32_t>(SellTowerReq::VT_POSY, posY, 0); }
  void add_objectID(int32_t objectID) { fbb_.AddElement<int32_t>(SellTowerReq::VT_OBJECTID, objectID, 0); }
  SellTowerReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SellTowerReqBuilder &operator=(const SellTowerReqBuilder &);
  flatbuffers::Offset<SellTowerReq> Finish() {
    auto o = flatbuffers::Offset<SellTowerReq>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<SellTowerReq> CreateSellTowerReq(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountUID = 0,
    int32_t posX = 0,
    int32_t posY = 0,
    int32_t objectID = 0) {
  SellTowerReqBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_objectID(objectID);
  builder_.add_posY(posY);
  builder_.add_posX(posX);
  return builder_.Finish();
}

struct UpgradeTowerReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTUID = 4,
    VT_POSX = 6,
    VT_POSY = 8,
    VT_OBJECTID = 10
  };
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  int32_t posX() const { return GetField<int32_t>(VT_POSX, 0); }
  int32_t posY() const { return GetField<int32_t>(VT_POSY, 0); }
  int32_t objectID() const { return GetField<int32_t>(VT_OBJECTID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           VerifyField<int32_t>(verifier, VT_POSX) &&
           VerifyField<int32_t>(verifier, VT_POSY) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct UpgradeTowerReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(UpgradeTowerReq::VT_ACCOUNTUID, accountUID, 0); }
  void add_posX(int32_t posX) { fbb_.AddElement<int32_t>(UpgradeTowerReq::VT_POSX, posX, 0); }
  void add_posY(int32_t posY) { fbb_.AddElement<int32_t>(UpgradeTowerReq::VT_POSY, posY, 0); }
  void add_objectID(int32_t objectID) { fbb_.AddElement<int32_t>(UpgradeTowerReq::VT_OBJECTID, objectID, 0); }
  UpgradeTowerReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UpgradeTowerReqBuilder &operator=(const UpgradeTowerReqBuilder &);
  flatbuffers::Offset<UpgradeTowerReq> Finish() {
    auto o = flatbuffers::Offset<UpgradeTowerReq>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<UpgradeTowerReq> CreateUpgradeTowerReq(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountUID = 0,
    int32_t posX = 0,
    int32_t posY = 0,
    int32_t objectID = 0) {
  UpgradeTowerReqBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_objectID(objectID);
  builder_.add_posY(posY);
  builder_.add_posX(posX);
  return builder_.Finish();
}

struct KillUnitReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTUID = 4,
    VT_OBJECTID = 6
  };
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  int32_t objectID() const { return GetField<int32_t>(VT_OBJECTID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID) &&
           verifier.EndTable();
  }
};

struct KillUnitReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(KillUnitReq::VT_ACCOUNTUID, accountUID, 0); }
  void add_objectID(int32_t objectID) { fbb_.AddElement<int32_t>(KillUnitReq::VT_OBJECTID, objectID, 0); }
  KillUnitReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  KillUnitReqBuilder &operator=(const KillUnitReqBuilder &);
  flatbuffers::Offset<KillUnitReq> Finish() {
    auto o = flatbuffers::Offset<KillUnitReq>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<KillUnitReq> CreateKillUnitReq(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountUID = 0,
    int32_t objectID = 0) {
  KillUnitReqBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_objectID(objectID);
  return builder_.Finish();
}

struct PlayerLoseReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTUID = 4,
    VT_PLAYERINDEX = 6
  };
  int64_t accountUID() const { return GetField<int64_t>(VT_ACCOUNTUID, 0); }
  int32_t playerIndex() const { return GetField<int32_t>(VT_PLAYERINDEX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ACCOUNTUID) &&
           VerifyField<int32_t>(verifier, VT_PLAYERINDEX) &&
           verifier.EndTable();
  }
};

struct PlayerLoseReqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountUID(int64_t accountUID) { fbb_.AddElement<int64_t>(PlayerLoseReq::VT_ACCOUNTUID, accountUID, 0); }
  void add_playerIndex(int32_t playerIndex) { fbb_.AddElement<int32_t>(PlayerLoseReq::VT_PLAYERINDEX, playerIndex, 0); }
  PlayerLoseReqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PlayerLoseReqBuilder &operator=(const PlayerLoseReqBuilder &);
  flatbuffers::Offset<PlayerLoseReq> Finish() {
    auto o = flatbuffers::Offset<PlayerLoseReq>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PlayerLoseReq> CreatePlayerLoseReq(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t accountUID = 0,
    int32_t playerIndex = 0) {
  PlayerLoseReqBuilder builder_(_fbb);
  builder_.add_accountUID(accountUID);
  builder_.add_playerIndex(playerIndex);
  return builder_.Finish();
}

}  // namespace P2P

struct ErrorMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT = 4
  };
  ProtocolCS::E_ErrorResult result() const { return static_cast<ProtocolCS::E_ErrorResult>(GetField<int32_t>(VT_RESULT, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct ErrorMsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(ProtocolCS::E_ErrorResult result) { fbb_.AddElement<int32_t>(ErrorMsg::VT_RESULT, static_cast<int32_t>(result), 0); }
  ErrorMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ErrorMsgBuilder &operator=(const ErrorMsgBuilder &);
  flatbuffers::Offset<ErrorMsg> Finish() {
    auto o = flatbuffers::Offset<ErrorMsg>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ErrorMsg> CreateErrorMsg(flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::E_ErrorResult result = ProtocolCS::E_ErrorResult_INVAILD_USERID) {
  ErrorMsgBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct MessageRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MessageType message_type() const { return static_cast<MessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0)); }
  const void *message() const { return GetPointer<const void *>(VT_MESSAGE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

struct MessageRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageType message_type) { fbb_.AddElement<uint8_t>(MessageRoot::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0); }
  void add_message(flatbuffers::Offset<void> message) { fbb_.AddOffset(MessageRoot::VT_MESSAGE, message); }
  MessageRootBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MessageRootBuilder &operator=(const MessageRootBuilder &);
  flatbuffers::Offset<MessageRoot> Finish() {
    auto o = flatbuffers::Offset<MessageRoot>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb,
    MessageType message_type = MessageType_NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageRootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

namespace Login {

}  // namespace Login

namespace Game {

}  // namespace Game

namespace P2P {

}  // namespace P2P

inline bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *union_obj, MessageType type) {
  switch (type) {
    case MessageType_NONE: return true;
    case MessageType_ErrorMsg: return verifier.VerifyTable(reinterpret_cast<const ErrorMsg *>(union_obj));
    case MessageType_Login_LoginReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Login::LoginReq *>(union_obj));
    case MessageType_Login_LoginAck: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Login::LoginAck *>(union_obj));
    case MessageType_Game_GameMatchingReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameMatchingReq *>(union_obj));
    case MessageType_Game_GameMatchingNotify: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameMatchingNotify *>(union_obj));
    case MessageType_Game_GameMatchingCancelReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameMatchingCancelReq *>(union_obj));
    case MessageType_Game_GameMatchingCancelNotify: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameMatchingCancelNotify *>(union_obj));
    case MessageType_Game_GameReadyReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameReadyReq *>(union_obj));
    case MessageType_Game_GameReadyAck: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameReadyAck *>(union_obj));
    case MessageType_Game_GameReadyNotify: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameReadyNotify *>(union_obj));
    case MessageType_Game_GameLoadingFinishReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameLoadingFinishReq *>(union_obj));
    case MessageType_Game_GameLoadingFinishAck: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameLoadingFinishAck *>(union_obj));
    case MessageType_Game_GameStartNotify: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameStartNotify *>(union_obj));
    case MessageType_Game_GameStatusNotify: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameStatusNotify *>(union_obj));
    case MessageType_Game_GameGiveUpReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameGiveUpReq *>(union_obj));
    case MessageType_Game_GameGiveUpNotify: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameGiveUpNotify *>(union_obj));
    case MessageType_Game_GameEndReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameEndReq *>(union_obj));
    case MessageType_Game_GameEndAck: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameEndAck *>(union_obj));
    case MessageType_Game_GameEndNotify: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::Game::GameEndNotify *>(union_obj));
    case MessageType_P2P_BuildReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::P2P::BuildReq *>(union_obj));
    case MessageType_P2P_SellTowerReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::P2P::SellTowerReq *>(union_obj));
    case MessageType_P2P_UpgradeTowerReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::P2P::UpgradeTowerReq *>(union_obj));
    case MessageType_P2P_KillUnitReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::P2P::KillUnitReq *>(union_obj));
    case MessageType_P2P_PlayerLoseReq: return verifier.VerifyTable(reinterpret_cast<const ProtocolCS::P2P::PlayerLoseReq *>(union_obj));
    default: return false;
  }
}

inline const ProtocolCS::MessageRoot *GetMessageRoot(const void *buf) {
  return flatbuffers::GetRoot<ProtocolCS::MessageRoot>(buf);
}

inline bool VerifyMessageRootBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ProtocolCS::MessageRoot>(nullptr);
}

inline void FinishMessageRootBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ProtocolCS::MessageRoot> root) {
  fbb.Finish(root);
}

}  // namespace ProtocolCS

#endif  // FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_
